웹 서버는 수천 개의 클라이언트와 동시에 통신하는데 서버가 통신하는 대상을 어떻게 식별하는 지 알아본다.

1. 개별접촉
   HTTP - 익명성, stateless, 요청 & 응답으로 통신하는 프로토콜

   - 개별 인사
   - 사용자 맞춤 추천
   - 저장된 사용자 정보: 신용카드나 주소를 DB 에 저장하는 사이트도 있음 -> 사용자가 누군지 한 번 식별하고 나면 쇼핑을 더 편하게 할 수 있게 사용자 정보를 사용
   - 세션 추적: HTTP 트랜잭션은 상태가 없다(stateless). 따라서 각 요청 & 응답은 독립적으로 일어나는데 사이트에서는 사용자가 사이트와 상호작용할 수 있게 사용자의 상태를 저장한다. (예를 들면 장바구니 기능). 이 때 사용자를 식별하는 여러 방법들이 있는데 그것들을 알아보자

2. HTTP 헤더

- From: 요청 헤더 , 사용자 이메일 주소
  - 악의적인 서버가 이메일 주소를 모아 스팸 메일을 보낼 수 있어서 잘 사용 안함
- User-Agent: 요청 헤더, 사용자 브라우저
  - 사용자가 쓰고 있는 브라우저의 이름, 버전 정보, 어떤 경우는 운영체제 정보까지 포함하여 서버에게 알려줌 -> 특정 브라우저에 맞는 콘텐츠를 최적화하는데는 유용할 수 있으나 특정 사용자를 식별하는 데는 도움 별로 안됨
- Referer: 요청 헤더, 사용자가 현재 링크를 타고 온 근원 페이지
  - 사용자의 웹 사용 형태나 취향을 더 잘 파악할 수 있음
- Authorzation: 요청 헤더, 사용자 이름 & 비번
- ETC

3. 클라이언트 IP 주소
   HTTP 헤더에 포함된 정보는 아니지만 서버는 HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알아낼 수 있음
   **약점**

- 클라이언트 IP 주소는 사용자가 아닌 사용자의 컴퓨터를 가리킴
- 많은 인터넷 서비스 제공자(ISP)는 사용자가 로그인하면 동적으로 IP 주소를 할당한다. 로그인 시간에 따라 매번 다른 주소를 받기때문에 사용자를 식별할 수 없다.
- 보안 강화 및 주소 관리문제로 네트워크 주소 변환(Network Address Translation, NAT) 방화벽을 통해 인터넷을 사용한다. 실제 IP 주소를 방화벽 뒤로 숨기고 방화벽 IP 주소로 변환
- 보통 HTTP 프락시와 게이트웨이는 원서버에 새로운 TCP 연결을 하기 때문에 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP 주소를 받는다.

4. 사용자 로그인
   사용자에게 로그인을 요청하고 사용자 식별정보 토큰을 Authorization 헤더에 담아 세션이 진행되는 내내 그 사용자에 대한 식별을 유지

5. 뚱뚱한 URL
   사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL 이라고 한다.
   **심각한 문제**

   - 새로운 사용자들에게 혼란을 줌
   - 공유하지 못하는 URL
   - 캐시를 사용할 수 없음
   - 서버 부하 가중
   - 이탈
   - 세션 간 지속성의 부재

6. 쿠키
   넷스케이프가 최초로 개발

6.1) 쿠키의 타입<br>
**세션 쿠키 & 지속 쿠키**
: 세션 쿠키는 사용자가 브라우저를 닫으면 삭제되고 지속 쿠키는 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재부팅해도 남아있다. 지속 쿠키는 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하기 위해 사용

6.2) 쿠키의 동작방식 <br>
처음 사용자가 웹 사이트에 방문하면 서버는 사용자에 대해서 아무것도 모름 -> 사용자가 다시 돌아왔을 때 사용자 식별을 위해 유일한 값을 쿠키에 할당 -> HTTP 응답 헤더에 기술되어 사용자에게 전달 -> 브라우저는 서버로 온 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 DB에 저장하고 나중에 사용자가 재방문하면 이 정보를 요청 헤더에 담아서 서버로 전송

- 크롬: Cookies 라는 SQLite 파일에 쿠키를 저장
- 쿠키는 일종의 상태 정보이며 서버가 생성 -> 클라이언트에 전달, 클라이언트는 그 쿠키를 유효한 사이트에만 다시 전달하고 관리함
