## Cache

- 불필요한 데이터 전송 down -> 네트워크 요금으로 인한 비용 삭감
- 네트워크 병목 방지; 대역폭을 늘리지 않아도 빠르게 페이지를 불러올 수 있음
- 원 서버에 대한 요청 줄여줌; 서버는 부하를 줄일 수 있고 성능이 향상됨
- 거리로 인한 지연을 줄여줌

### 불필요한 데이터 전송

복수의 클라이언트들이 원 서버에 동일한 데이터를 요청할 때 캐싱을 통해서 불필요한 전송을 줄이고 효율을 높힐 수 있다.

### 대역폭 병목

많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공함. 만약 클라이언트가 빠른 LAN 에 있는 캐시로부터 사본을 가져온다면 성능을 대폭 개선할 수 있음.
(WAN vs LAN) p.186 이미지 참조

### Flash Crowds

갑작스런 사건으로 인해 많은 사람이 동시에 웹에 접근할 때 트래픽 급증으로 인해 장애를 일으킨다.

### 거리로 인한 지연

### cache hit & cache miss

cache hit 은 캐시에 요청이 도착했을 때 요청에 대응하는 사본이 있어서 요청을 처리하는 것. cache miss 는 사본이 없어서 원 서버로 요청을 전달하는 것

### 재검사 (revalidation, HTTP 신선도 검사)

원 서버의 데이터가 변경될 수 있기 때문에 캐시는 반드시 가지고 있는 사본이 최신인 지 서버를 통해 점검해야 함
예를 들어, If-Modified-Since 헤더를 포함시켜 요청을 보내면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 뜻

**문서 적중률 & 바이트 적중률 = 캐시 성능에 대한 유용한 지표**

## 캐시 처리 단계

1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메세지를 읽음
2. 파싱: 메세지를 파싱하여 URL 과 헤더들 추출
3. 검색: 로컬 복사본(메모리 혹은 근접한 다른 컴퓨터) 이 있는 지 검사 후 없으면 사본을 받아와서 로컬에 저장
4. 신선도 검사: 캐시된 사본이 최신 정보인지 검사하고 그렇지 않을 경우 서버에 변경사항이 있는 지 확인
5. 응답 생성: 새로운 헤더와 캐시된 본문으로 응답 메세지 생성
6. 발송: 네트워크를 통해 클라이언트에게 응답 리턴
7. 로깅: 선택사항으로 로그파일에 트랜잭션에 대해 서술한 로그를 남김

## 사본을 신선하게 유지

### 문서 만료

HTTP 는 Cache-Control & Expires 라는 헤더들을 통해 원 서버가 각 문서에 유효기간을 붙이도록 함.

### 서버 재검사

캐시된 문서가 만료되었을 경우 캐시-> 원 서버에게 문서가 변경되었는 지 확인하는 절차를 서버 재검사라고 함

- 변경되었을 경우, 다시 새로운 사본을 가져와 로컬에 저장하고 클라이언트 전송
- 변경되지 않았을 경우, 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신

## 캐시 제어

문서의 캐시 가능 여부를 서버가 설정

- Cache-Control: no-store / no-cache / must-revalidate / max-age header 를 응답에 첨부
