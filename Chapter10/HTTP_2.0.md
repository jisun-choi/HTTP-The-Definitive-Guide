### HTTP/2.0의 등장배경

- HTTP/1.1의 메세지 포맷은 구현의 단순성, 접근성에 최적화
- 커넥션 하나를 통해 요청 하나를 받고 응답 하나만을 받는 HTTP 의 메세지 교환방식은 심각한 latency 이슈를 피할 수 없음.
- 이 문제를 해결하기 위해 병렬 커넥션, 파이프라인 커넥션이 도입되었지만 근본적인 성능 개선 불가
- MS, 구글 등에서 프로토콜을 개발하기 시작했고 구글의 SPDY 를 베이스로 HTTP/2.0 프로토콜을 설계

### 개요

- HTTP/2.0은 서버 & 클라이언트 사이의 TCP 커넥션 위에서 동작하며 TCP 커넥션을 초기화 하는 것은 클라이언트
- HTTP/2.0 의 요청, 응답은 길이가 정의된 한 개 이상의 프레임에 담기고 HTTP 헤더는 압축되어 담김
- 한 개의 스트림이 한 쌍의 요청과 응답을 처리
- 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어 질 수 있어 여러 개의 요청과 응답을 동시에 처리할 수 있음
- 서버 푸시: 서버가 클라이언트에게 필요하다고 생각하는 리소스라면 요청이 없이도 응답을 보내줄 수 있음

### HTTP/1.1 과의 차이점

- 프레임
  - 2.0에서 모든 메세지는 프레임에 담겨 전송. (p.289 이미지 참조)
- 스트림 & 멀티플렉싱
  - 2.0에서는 하나의 커넥션에 여러 스트림이 동시에 열릴 수 있음
  - 또한 스트림이 우선순위도 가질 수 있음
- 헤더 압축
- 서버 푸시

### 보안 이슈

- Intermediary Encapsulation Attacks
  - HTTP/2.0 메세지를 프록시가 HTTP/1.1 메세지로 변환할 때 2.0은 헤더 필드의 이름, 값을 바이너리로 인코딩하기 때문에 어떤 문자열도 사용할 수 있게 되기 때문에 메세지 변질의 가능성을 내포한다.
- 긴 커넥션 유지로 개인정보 누출 우려
